#!/usr/bin/env ruby
# ------------------------------------------------------
# File          : ghcurl.rb
# Authors       : ccmywish <ccmywish@qq.com>
# Created on    : <2022-04-12>
# Last modified : <2022-04-26>
#
# ghcurl:
#
#   Download files and install from Github releases
#
# ------------------------------------------------------

require 'ghcurl'
require 'octokit'
require 'highline'
require 'cliswitch'
require 'fileutils'

module Ghcurl

  WAREHOUSE = File.expand_path("~/.cache/ghcurl")
  BIN_PATH  = ENV['GHCURL_BIN_PATH'].chomp('/') || "/usr/local/bin"
  HL = HighLine.new

  class Error < StandardError; end


  def bold(str)       "\e[1m#{str}\e[0m" end
  def green(str)      "\e[32m#{str}\e[0m" end
  def blue(str)       "\e[34m#{str}\e[0m" end

  
  def log(msg)
    puts blue(bold("ghcurl: #{msg}"))
  end
  

  def curl(url, name)
    cmd = "curl -L #{url} --create-dirs -o #{WAREHOUSE}/#{name}"
    system cmd
    log "Downloaded to #{WAREHOUSE}/#{name}"
  end


  def get_filters

    arches = [ 
                ['amd64', 'x86_64', 'x64'], 
                ['386',   'i686'],
                ['arm64', 'aarch64'], 
                ['armv6', 'arm'],
             ]
    
    oses = [
             ['linux'],
             ['freebsd'],
             ['mac', 'apple', 'darwin'],
             ['windows']
           ]

    fs = RUBY_PLATFORM.split('-')
    os = ""
    arch = ""
    fs.each do |f|
      case f
      when 'linux'  then os = 'linux'
      when 'mac','macOS' then os = 'mac'
      when 'ucrt', 'mingw', 'windows' then os = 'windows' 
      when 'x86_64' then arch = 'x86_64'
      when 'x86'    then arch = 'x86'
      when 'amd64'  then arch = 'amd64'  
      when 'arm64'  then arch = 'arm64' 
      when 'armv6'  then arch = 'armv6' 
      end
    end

    approval, refuse  = [], []
    # [os, arch].each { approval << _1 unless _1.nil? }

    if os 
      i = oses.each_with_index do |type, index|
        break index if type.include? os
      end
      if !i.nil?
        tmp = oses.dup
        tmp.delete_at(i)
        refuse.concat tmp.flatten
      end
    end


    if arch
      i = arches.each_with_index do |type, index|
        break index if type.include? arch
      end
      if !i.nil?
        tmp = arches.dup
        tmp.delete_at(i)
        refuse.concat tmp.flatten
      end
    end

    # Debug
    # puts "=> Approval and refuse"
    # p [os, arch]
    # p refuse
    
    # Now we only refuse others
    return refuse
  
  end


  def download(repo, regexp, version: nil)

    if repo =~ /^https:\/\/github.com/
      require 'uri'
      uri = URI(repo)
      # index 1, take 2
      repo = uri.path.split('/')[1,2].join('/')
    elsif !repo.include?('/')
      got_repo = DEFAULT_WARES[repo.to_sym]
      if not got_repo
        user = HL.ask "Who developed the awesome '#{repo}' ? "
        repo = user + '/' + repo
      else
        repo = got_repo
        log "Use the popular repo #{repo}"
      end
    end

    log "checking..."
    unless version
      doc = Nokogiri::HTML5 URI.open("https://github.com/#{repo}/releases/latest")
    else
      doc = Nokogiri::HTML5 URI.open("https://github.com/#{repo}/releases/tag/v#{version}")
    end


    links = doc.css("li>a[href^='/#{repo}/releases/download']")
    if links.empty?
      puts doc.css('li a').map(&:to_s)
      log <<~EOE
      The search result is empty, check the args:
              repo:    #{repo}
              version: #{version ? version:'nil'}

      EOE
      puts
    end


    links = links.map { _1['href'] }


    if regexp 
      filtered = links.select do
        _1 =~ /#{regexp}/
      end
    else
      refuse = get_filters()    
      filtered = links.select do |l|
        refuse.all? do |f|
          l !~ /#{f}/
        end
      end
    end


    if filtered.size == 1
      link = filtered[0].split('/').last 
    else 
      if filtered.size == 0
        links_for_user = links.map { _1.split('/').last }
      else
        links_for_user = filtered.map { _1.split('/').last }
      end
      link = HL.choose do |menu|
        menu.index_color  = :rgb_77bbff
        menu.prompt = "Which one do you want to download? "
        menu.choices( *links_for_user )
      end
    end

    url = "https://github.com" + links[0].split('/')[0..-2].join('/') + '/' + link

    log "Downloading #{url}"
    
    download_name = link.split('/').last

    curl(url, download_name)
    return download_name
  end



  def install(dl_name, rename_as: nil,  install_to: nil)

    if install_to.nil?
      install_to = BIN_PATH
    end

    target = "#{WAREHOUSE}/#{dl_name}"

    if target.end_with?('.deb')
      log "Install deb package for you"
      system "sudo dpkg -i #{target}"
      return
    end

    if target.end_with?('.rpm')
      log "Install rpm package for you"
      system "sudo rpm -i #{target}"
      return
    end


    #
    # The zipped file
    #
    
    zip_flag = false
    # unzipped to dir
    unzip_dir = ""
    # unzipped files
    files = ""
    # our desired software name
    name  = ""
    
    if target.match?(/\.zip$/) or target.match?(/\.tar\.(\w){1,3}/)

      zip_flag = true

    # unzip 
    if target.match? /\.zip$/
      log "Unzip zip file"
      unzip_dir = target.chomp('.zip')
      system "unzip -q #{target} -d #{unzip_dir}"
    end
    
    # .gz, .bz2, .xz
    if target.match? /\.tar\.(\w){1,3}/
      log "Unzip tar file"
      unzip_dir = target.split('.')[0..-3].join('.')
      FileUtils.mkdir_p(unzip_dir)
      system "tar xf #{target} --directory=#{unzip_dir}"
    end
    

    
    def _iterate_dir(dir)
      result = []
      chd = Dir.children(dir)
      chd_files = chd.select{|f| File.file? "#{dir}/#{f}"}
      
      chd_files.each { result << "#{dir}/#{_1}"[2..] }

      chd_dirs  = chd.select{|d| File.directory?("#{dir}/#{d}") && ( d != '.git')}
      chd_dirs.each do |d|
        sub_dir = "#{dir}/#{d}"
        result.concat _iterate_dir(sub_dir)
      end
      result
    end
    


    Dir.chdir unzip_dir do
      files = _iterate_dir('.')
    end

    
    if files.size > 1
      name = HL.choose do |menu|
        menu.index_color  = :rgb_77bbff
        menu.prompt = "Which one do you want to install? "
        menu.choices( *files )
      end
    else
      name = files[0]
    end

    end # end of zipped file handle


    if !zip_flag
      # downloaded name in WAREHOUSE
      name = dl_name
    end


    if (name.size > 10     ||
        name.include?('.') ||
        name.include?('-') ||
        name.include?('_')) && (not rename_as)
      log "Do you want to rename the '#{name}'?"
      re = HL.ask "Input name, or just leave it blank to say no."
      if !re.empty? 
        rename_as = re
      end
    end

    
    if zip_flag
      # add unzip_dir prefix
      name = unzip_dir.delete_prefix(WAREHOUSE + '/') + '/' + name
    end

    if rename_as 
      log "Renamed as '#{rename_as}'"
    end


    case RUBY_PLATFORM
    when /ucrt/i, /mingw/i
      install_on_windows(name, install_to, rename_as)
    else
      install_on_nix(name, install_to, rename_as)
    end
  end


  def install_on_nix(name, install_to, rename_as)
    install_to = install_to.chomp('/')
    target = WAREHOUSE + '/' + name

    if test 'd', install_to
      log "Ready to install #{name}"
      if rename_as
        dest = "#{install_to}/#{rename_as}"
        system "sudo cp #{target} " + dest
        system "sudo chmod +x " + dest
        log "Installed as " + dest
      else
        cmd = "sudo install -Dt #{install_to} -m 755 #{target} "
        system cmd
        log "Install #{name} to " + install_to
      end
      log "Install finish!"
    else
      log "#{install_to} is not a directory!"
    end

  end


  def install_on_windows
    log "Sorry, not implemented yet on Windows! Can you help?"
  end


  #
  # For -l option
  #
  def list_wares
    puts blue("ghcurl: #{WAREHOUSE}")
    Dir.children(WAREHOUSE).each_with_index do |dict,i|
      puts "#{blue(i+1)}. #{bold(green(dict))}"
    end
  end


  #
  # For -d option
  #
  def delete_wares(name)
    begin 

    if name.nil? 
      re = HL.ask "Do you want to delete all downloaded files?"
      case re.downcase
      when '','y','ye','yes','true'
        FileUtils.rm_rf WAREHOUSE
        log "Delete all done"
      end
    else
      FileUtils.rm WAREHOUSE + '/' + name
      log "Delete #{name} done"
    end

    rescue Exception => e
      puts bold(red("ghcurl: #{e}"))
      list_wares
    end

  end # end def delete_wares


  def help
    puts <<~EOC
    ghcurl (v#{VERSION}): Download files and install from Github releases

    Default install to env 'GHCURL_BIN_PATH' or /usr/local/bin

    usage:
      ghcurl [user]/repo [regexp] => Search latest version with regexp to download
      ghcurl repo [re] -v tag     => Download a specific tag version
      ghcurl repo [deb/rpm]       => Download and install deb/rpm package
      ghcurl repo [re] -i [path]  => Download and install to path
      ghcurl repo [re] -i -r name => Download and install as 'name'
      ghcurl -l                   => List downloaded files
      ghcurl -d [name]            => Delete a downloaded file or all
      ghcurl -h                   => Print this help

    example:
      ghcurl bat         => Search sharkdp/bat the latest
      ghcurl cli deb -i  => Search cli/cli /deb/
      ghcurl rbspy/rbspy 'x86_64.*linux' -v0.11.1
      ghcurl dlvhdr/gh-dash linux-amd64 -i -r 'gd'

    EOC
  end

end



####################
# main: CLI Handling
####################
extend Ghcurl

class Ghcurl::CLI < CliSwitch
  option name: 'install', short: '-i', arg_required: 'optional'
  option name: 'rename',  short: '-r', arg_required: 'required'
  option name: 'version', short: '-v', arg_required: 'required'
  option name: 'help',    short: '-h', long: '--help', arg_required: 'noarg'
  option name: 'list',    short: '-l', arg_required: 'noarg'
  option name: 'delete',  short: '-d', arg_required: 'optional'
end

args, opts = Ghcurl::CLI.new.parse(ARGV)

if args.empty? and opts.empty?
  help
  exit 
end


repo_or_name, regexp = args[0], args[1]
version = nil
need_install = false
install_to = nil
rename_as  = nil

opts.each do 
  case _1.name 
  when 'help'
    help
    exit
  when 'list'
    list_wares
    exit
  when 'delete'
    delete_wares(_1.next_arg)
    exit
  when 'version'
    version = _1.next_arg
  when 'install'
    need_install = true
    install_to = _1.next_arg
  when 'rename'
    rename_as = _1.next_arg
  end
end

# Debug
# p repo_or_name
# p regexp
# p need_install
# p install_to
# p rename_as

begin
dl_name = download(repo_or_name, regexp, version: version)
if need_install
  install(dl_name, rename_as: rename_as, install_to: install_to)
end
rescue Interrupt
end
