#!/usr/bin/env ruby
# ------------------------------------------------------
# File          : ghcurl.rb
# Authors       : ccmywish <ccmywish@qq.com>
# Created on    : <2022-04-12>
# Last modified : <2022-04-14>
#
# ghcurl:
#
#   Download files and install from Github releases
#
# ------------------------------------------------------

require 'ghcurl'
require 'nokogiri'
require 'open-uri'
require 'highline'
require 'cliswitch'

module Ghcurl

  WAREHOUSE = File.expand_path("~/.cache/ghcurl")
  BIN_PATH  = ENV['GHCURL_BIN_PATH'] || "/usr/local/bin"
  HL = HighLine.new

  class Error < StandardError; end


  def bold(str)       "\e[1m#{str}\e[0m" end
  def green(str)      "\e[32m#{str}\e[0m" end
  def blue(str)       "\e[34m#{str}\e[0m" end

  
  def log(msg)
    puts blue(bold("ghcurl: #{msg}"))
  end
  

  def curl(url, name)
    #if !test('d', WAREHOUSE)
    #  require 'fileutils'
    #  FileUtils.mkdir_p(WAREHOUSE)
    #end
    cmd = "curl -L #{url} --create-dirs -o #{WAREHOUSE}/#{name}"
    system cmd
    log "Downloaded to #{WAREHOUSE}/#{name}"
  end


  def get_filters

    arches = [ 
                ['amd64', 'x86_64', 'x64'], 
                ['386',   'i686'],
                ['arm64', 'aarch64'], 
                ['armv6', 'arm'],
             ]
    
    oses = [
             ['linux'],
             ['freebsd'],
             ['mac', 'apple', 'darwin'],
             ['windows']
           ]

    fs = RUBY_PLATFORM.split('-')
    os = ""
    arch = ""
    fs.each do |f|
      case f
      when 'linux'  then os = 'linux'
      when 'mac','macOS' then os = 'mac'
      when 'ucrt', 'mingw', 'windows' then os = 'windows' 
      when 'x86_64' then arch = 'x86_64'
      when 'x86'    then arch = 'x86'
      when 'amd64'  then arch = 'amd64'  
      when 'arm64'  then arch = 'arm64' 
      when 'armv6'  then arch = 'armv6' 
      end
    end

    approval, refuse  = [], []
    # [os, arch].each { approval << _1 unless _1.nil? }

    if os 
      i = oses.each_with_index do |type, index|
        break index if type.include? os
      end
      if !i.nil?
        tmp = oses.dup
        tmp.delete_at(i)
        refuse.concat tmp.flatten
      end
    end


    if arch
      i = arches.each_with_index do |type, index|
        break index if type.include? arch
      end
      if !i.nil?
        tmp = arches.dup
        tmp.delete_at(i)
        refuse.concat tmp.flatten
      end
    end

    # Debug
    # puts "=> Approval and refuse"
    # p [os, arch]
    # p refuse
    
    # Now we only refuse others
    return refuse
  
  end


  def download(repo, regexp, version: nil)

    if repo =~ /^https:\/\/github.com/
      require 'uri'
      uri = URI(repo)
      # index 1, take 2
      repo = uri.path.split('/')[1,2].join('/')
    elsif !repo.include?('/')
      got_repo = DEFAULT_WARES[repo.to_sym]
      if not got_repo
        user = HL.ask "Who developed the awesome '#{repo}' ? "
        repo = user + '/' + repo
      else
        repo = got_repo
        log "Use the popular repo #{repo}"
      end
    end

    log "checking..."
    unless version
      doc = Nokogiri::HTML5 URI.open("https://github.com/#{repo}/releases/latest")
    else
      doc = Nokogiri::HTML5 URI.open("https://github.com/#{repo}/releases/tag/v#{version}")
    end


    links = doc.css("li>a[href^='/#{repo}/releases/download']")
    if links.empty?
      puts doc.css('li a').map(&:to_s)
      log <<~EOE
      The search result is empty, check the args:
              repo:    #{repo}
              version: #{version ? version:'nil'}

      EOE
      puts
    end


    links = links.map { _1['href'] }


    if regexp 
      filtered = links.select do
        _1 =~ /#{regexp}/
      end
    else
      refuse = get_filters()    
      filtered = links.select do |l|
        refuse.all? do |f|
          l !~ /#{f}/
        end
      end
    end


    if filtered.size == 1
      link = filtered[0].split('/').last 
    else 
      if filtered.size == 0
        links_for_user = links.map { _1.split('/').last }
      else
        links_for_user = filtered.map { _1.split('/').last }
      end
      link = HL.choose do |menu|
        menu.index_color  = :rgb_77bbff
        menu.prompt = "Which one do you want to download? "
        menu.choices( *links_for_user )
      end
    end

    url = "https://github.com" + links[0].split('/')[0..-2].join('/') + '/' + link

    log "Downloading #{url}"
    
    download_name = link.split('/').last

    curl(url, download_name)
    return download_name
  end


  def install(dl_name, rename_as: nil,  install_to: nil)

    if install_to.nil?
      install_to = BIN_PATH
    end

    target = "#{WAREHOUSE}/#{dl_name}"

    if target.end_with?('.deb')
      log "Install deb package for you"
      system "sudo dpkg -i #{target}"
      return
    end

    if target.end_with?('.rpm')
      log "Install rpm package for you"
      system "sudo rpm -i #{target}"
      return
    end


    if target.end_with?('tar.gz')
    end
    
    
    log "Do you want to rename or install it to a different path?"
    re = HL.ask "Input name, or just enter to say no."
    if !re.empty? 
      install_to = re
    end
    
    case RUBY_PLATFORM
    when /ucrt/i, /mingw/i
      install_on_windows(dl_name, install_to)
    else
      install_on_nix(dl_name, install_to)
    end
    log "Install finish!"
  end


  def install_on_nix(ware, install_to)

    if test 'd', install_to
      cmd = "sudo install -Dt #{install_to} -m 755 #{target} "
      system cmd
      log "Install #{ware} to " + install_to

    else
      unless install_to.include?('/')
        # User just give it another name
        install_to = BIN_PATH + '/' + install_to
      else
        # User give it a path and its name
      end
      log "Installed as " + install_to
      system "sudo cp #{target} #{install_to}"
      system "sudo chmod +x #{install_to}"
    end

  end


  def install_on_windows
    log "Sorry, not implemented yet!"
  end


  #
  # For -l option
  #
  def list_wares
    puts blue("ghcurl: #{WAREHOUSE}")
    Dir.children(WAREHOUSE).each_with_index do |dict,i|
      puts "#{blue(i+1)}. #{bold(green(dict))}"
    end
  end


  #
  # For -d option
  #
  def delete_wares(name)
    require 'fileutils'

    begin 

    if name.nil? 
      re = HL.ask "Do you want to delete all downloaded files?"
      case re.downcase
      when '','y','ye','yes','true'
        FileUtils.rm_rf WAREHOUSE
        log "ghcurl: Delete done"
      end
    else
      FileUtils.rm WAREHOUSE + '/' + name
      log "ghcurl: Delete done"
    end

    rescue Exception => e
      puts bold(red("ghcurl: #{e}"))
      list_wares
    end

  end # end def delete_wares


  def help
    puts <<~EOC
    ghcurl (v#{VERSION}): Download files and install from Github releases

    Default install to env 'GHCURL_BIN_PATH' or /usr/local/bin

    usage:
      ghcurl [user]/repo [regexp] => Search latest version with regexp to download
      ghcurl repo [re] -v tag     => Download a specific tag version
      ghcurl repo [deb/rpm]       => Download and install deb/rpm package
      ghcurl repo [re] -i [path]  => Download and install to path
      ghcurl repo [re] -i -r name => Download and install as 'name'
      ghcurl -l                   => List downloaded files
      ghcurl -d [name]            => Delete a downloaded file or all
      ghcurl -h                   => Print this help

    example:
      ghcurl bat         => Search sharkdp/bat the latest
      ghcurl cli deb -i  => Search cli/cli /deb/
      ghcurl rbspy/rbspy 'x86_64.*linux' -v0.11.1

    EOC
  end

end



####################
# main: CLI Handling
####################
extend Ghcurl

class Ghcurl::CLI < CliSwitch
  option name: 'install', short: '-i', arg_required: 'optional'
  option name: 'rename',  short: '-r', arg_required: 'required'
  option name: 'version', short: '-v', arg_required: 'required'
  option name: 'help',    short: '-h', long: '--help', arg_required: 'noarg'
  option name: 'list',    short: '-l', arg_required: 'noarg'
  option name: 'delete',  short: '-d', arg_required: 'optional'
end

args, opts = Ghcurl::CLI.new.parse(ARGV)

if args.empty? and opts.empty?
  help
  exit 
end


repo_or_name, regexp = args[0], args[1]
version = nil
need_install = false
install_to = nil
rename_as  = nil

opts.each do 
  case _1.name 
  when 'help'
    help
    exit
  when 'list'
    list_wares
    exit
  when 'version'
    version = _1.next_arg
  when 'install'
    need_install = true
    install_to = _1.next_arg
  when 'rename'
    rename_as = _1.next_arg
  end
end

# Debug
# p repo_or_name
# p regexp
# p need_install
# p install_to

begin
dl_name = download(repo_or_name, regexp, version: version)
if need_install
  install(dl_name, rename_as: rename_as, install_to: install_to)
end
rescue Interrupt
end
